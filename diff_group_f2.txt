diff --git a/.vscode/c_cpp_properties.json b/.vscode/c_cpp_properties.json
new file mode 100644
index 0000000..9e6febf
--- /dev/null
+++ b/.vscode/c_cpp_properties.json
@@ -0,0 +1,16 @@
+{
+    "configurations": [
+        {
+            "name": "Linux",
+            "includePath": [
+                "${workspaceFolder}/**"
+            ],
+            "defines": [],
+            "compilerPath": "/usr/bin/clang",
+            "cStandard": "c17",
+            "cppStandard": "c++14",
+            "intelliSenseMode": "linux-clang-x64"
+        }
+    ],
+    "version": 4
+}
\ No newline at end of file
diff --git a/app/spi_test/makefile b/app/spi_test/makefile
new file mode 100644
index 0000000..fef5e2d
--- /dev/null
+++ b/app/spi_test/makefile
@@ -0,0 +1,17 @@
+# EPOS Application Makefile
+
+include ../../makedefs
+
+all: install
+
+$(APPLICATION):	$(APPLICATION).o $(LIB)/*
+		$(ALD) $(ALDFLAGS) -g -o $@ $(APPLICATION).o
+
+$(APPLICATION).o: $(APPLICATION).cc $(SRC)
+		$(ACC) $(ACCFLAGS) -g -o $@ $<
+
+install: $(APPLICATION)
+		$(INSTALL) $(APPLICATION) $(IMG)
+
+clean:
+		$(CLEAN) *.o $(APPLICATION)
diff --git a/app/spi_test/spi_test.cc b/app/spi_test/spi_test.cc
new file mode 100644
index 0000000..c3a463f
--- /dev/null
+++ b/app/spi_test/spi_test.cc
@@ -0,0 +1,49 @@
+#include <machine/riscv/riscv_spi.h>
+#include <utility/ostream.h>
+#include <utility/ostream.h>
+
+using namespace EPOS;
+OStream cout;
+
+int main() {
+    
+
+    // Configure SPI
+    SPI_E spi;
+    
+    char init_cmd[] = {0x40, 0x00, 0x00, 0x00, 0x00, 0x95, 0xff, 0x00}; //send command data to the MMC chip
+    spi.write(init_cmd, 6);
+    
+    char data[15] = {0}; // create an data array to read the response data
+    spi.read(data, 15); // read the response data from the device
+
+    for(int i=0; i<15; i++) {
+        if (data[i] != 0){ //verify if read got the data
+            cout << "Receive data in position " << i << " is " << (int) data[i] << endl;
+            /*
+                Return data from this test, in our computer is:
+                Some links indicates is a common initialize error, and as we dont know the manual of the mmc
+                https://stackoverflow.com/questions/5048450/c-initializing-an-sd-card-in-spi-mode-always-reads-back-0xff
+
+                Receive data in position 0 is 255
+                Receive data in position 1 is 255
+                Receive data in position 2 is 255
+                Receive data in position 3 is 255
+                Receive data in position 4 is 255
+                Receive data in position 5 is 255
+                Receive data in position 6 is 255
+                Receive data in position 7 is 4
+                The last thread has exited!
+                Rebooting the machine ...
+                Machine::reboot()
+            
+            
+            */
+        }
+    }
+    
+
+
+    return 0;
+    
+}
diff --git a/app/spi_test/spi_test_traits.h b/app/spi_test/spi_test_traits.h
new file mode 100644
index 0000000..4c35c1b
--- /dev/null
+++ b/app/spi_test/spi_test_traits.h
@@ -0,0 +1,147 @@
+#ifndef __traits_h
+#define __traits_h
+
+#include <system/config.h>
+
+__BEGIN_SYS
+
+// Build
+template<> struct Traits<Build>: public Traits_Tokens
+{
+    // Basic configuration
+    static const unsigned int MODE = LIBRARY;
+    static const unsigned int ARCHITECTURE = RV64;
+    static const unsigned int MACHINE = RISCV;
+    static const unsigned int MODEL = SiFive_U;
+    static const unsigned int CPUS = 1;
+    static const unsigned int NODES = 1; // (> 1 => NETWORKING)
+    static const unsigned int EXPECTED_SIMULATION_TIME = 60; // s (0 => not simulated)
+
+    // Default flags
+    static const bool enabled = true;
+    static const bool monitored = false;
+    static const bool debugged = true;
+    static const bool hysterically_debugged = false;
+
+    // Default aspects
+    typedef ALIST<> ASPECTS;
+};
+
+
+// Utilities
+template<> struct Traits<Debug>: public Traits<Build>
+{
+    static const bool error   = true;
+    static const bool warning = true;
+    static const bool info    = false;
+    static const bool trace   = false;
+};
+
+template<> struct Traits<Lists>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Spin>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Heaps>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+template<> struct Traits<Observers>: public Traits<Build>
+{
+    // Some observed objects are created before initializing the Display
+    // Enabling debug may cause trouble in some Machines
+    static const bool debugged = false;
+};
+
+
+// System Parts (mostly to fine control debugging)
+template<> struct Traits<Boot>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Setup>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Init>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Framework>: public Traits<Build>
+{
+};
+
+template<> struct Traits<Aspect>: public Traits<Build>
+{
+    static const bool debugged = hysterically_debugged;
+};
+
+
+__END_SYS
+
+// Mediators
+#include __ARCHITECTURE_TRAITS_H
+#include __MACHINE_TRAITS_H
+
+__BEGIN_SYS
+
+
+// API Components
+template<> struct Traits<Application>: public Traits<Build>
+{
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = Traits<Machine>::HEAP_SIZE;
+    static const unsigned int MAX_THREADS = Traits<Machine>::MAX_THREADS;
+};
+
+template<> struct Traits<System>: public Traits<Build>
+{
+    static const unsigned int mode = Traits<Build>::MODE;
+    static const bool multithread = (Traits<Application>::MAX_THREADS > 1);
+    static const bool multiheap = Traits<Scratchpad>::enabled;
+
+    static const unsigned long LIFE_SPAN = 1 * YEAR; // s
+    static const unsigned int DUTY_CYCLE = 1000000; // ppm
+
+    static const bool reboot = true;
+
+    static const unsigned int STACK_SIZE = Traits<Machine>::STACK_SIZE;
+    static const unsigned int HEAP_SIZE = (Traits<Application>::MAX_THREADS + 1) * Traits<Application>::STACK_SIZE;
+};
+
+template<> struct Traits<Thread>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+    static const bool trace_idle = hysterically_debugged;
+    static const bool preemptive = true;
+    static const unsigned int QUANTUM = 100000; // us
+};
+
+template<> struct Traits<Scheduler<Thread>>: public Traits<Build>
+{
+    static const bool debugged = Traits<Thread>::trace_idle || hysterically_debugged;
+};
+
+template<> struct Traits<Synchronizer>: public Traits<Build>
+{
+    static const bool enabled = Traits<System>::multithread;
+};
+
+template<> struct Traits<Alarm>: public Traits<Build>
+{
+    static const bool visible = hysterically_debugged;
+};
+
+template<> struct Traits<Address_Space>: public Traits<Build> {};
+
+template<> struct Traits<Segment>: public Traits<Build> {};
+
+__END_SYS
+
+#endif
diff --git a/include/machine/riscv/riscv_spi.h b/include/machine/riscv/riscv_spi.h
new file mode 100644
index 0000000..8c593b5
--- /dev/null
+++ b/include/machine/riscv/riscv_spi.h
@@ -0,0 +1,181 @@
+// EPOS RISC-V SPI Mediator Declarations
+
+#ifndef __riscv_spi_h
+#define __riscv_spi_h
+
+#include <architecture/cpu.h>
+#include <machine/spi.h>
+#include <system/memory_map.h>
+#include <utility/ostream.h>
+
+using namespace EPOS;
+
+
+__BEGIN_SYS
+
+
+class SPI_E : public SPI_Common
+{
+private:
+    typedef CPU::Reg8 Reg8;
+    typedef CPU::Reg32 Reg32;
+public:
+
+    enum {
+        SCKDIV  = 0x00, // clock divisor
+        SCKMODE = 0x04, // SPI mode 
+        CSID    = 0x10, // Chip select 
+        CSDEF   = 0x14, // Chip select default 
+        CSMODE  = 0x18, // Chip select mode 
+        DELAY0  = 0x28, // Delay control 0
+        DELAY1  = 0x2c, // Delay control 1
+        FMT     = 0x40, // Frame format
+        TXDATA  = 0x48, // Transmit data 
+        RXDATA  = 0x4c, // Receive data 
+        TXMARK  = 0x50, // Transmit watermark 
+        RXMARK  = 0x54, // Receive watermark 
+        FCTRL   = 0x60, // Flash interface control 
+        FFMT     = 0x64, // Flash interface timing 
+        IE      = 0x70, // Interrupt enable 
+        IP      = 0x74, // Interrupt pending 
+        DIV     = 0x80 // Set the SPI clock frequency
+        
+    };
+
+    static const unsigned int CLOCK = Traits<SPI>::CLOCK;
+
+    SPI_E() {
+        config(CLOCK, 0, 0, 250000, 8);
+    }
+
+    void config(unsigned int clock, unsigned int protocol, unsigned int mode, unsigned int bit_rate, unsigned int data_bits) {
+        // Set the clock divisor
+        unsigned int sckdiv = (clock / (2 * bit_rate) ) - 1;
+        reg(SCKDIV) = sckdiv & 0xffffffff;
+        
+        // Set the SPI mode and control register
+        unsigned int sckmode =  0x0;
+        reg(SCKMODE) = sckmode;
+
+
+        reg(CSMODE) = 0x01; //mode hold
+        reg(CSID) = 0x00; //choose first id (see device tree and the spi@10050000 device)
+
+        // Set the frame format
+        unsigned int fmt = 0x0;  // clear all the bits
+        fmt = ((protocol << 0) | (0 << 2) | (mode << 3) | (data_bits << 16)); // set endian, mode, protocol and data_bits
+        reg(FMT) = fmt;
+        
+        // Enable interruptions
+        reg(IE) = 0x03;
+        reg(TXMARK) =  0x01;
+        reg(RXMARK) = 0x00;
+    }
+
+    void put(int data) {
+        // Wait until there is space to write
+        // another approach is described in the ready_to_put function
+        while ((reg(IP) & 0x1) == 0) {
+            /*
+                The IP register is a read-only register that 
+                stores the status of various interrupt flags. 
+                In this case, the IP[0] bit indicates whether 
+                the transmit buffer is full or not. If the IP[0] 
+                bit is set to 0, it means there is space available 
+                in the buffer to write new data
+            
+            */
+        }
+
+        // Write the data
+        reg(TXDATA) = data;
+    }
+
+    int get() {
+        // Wait until there is data to read
+        // another approach is described in the ready_to_get function
+        while ((reg(IP) & 0x2) == 0) {
+            // same explanation of the put function
+            // we used this approach because we could skip reading the register
+            // if we dont want to consume its data
+        }
+
+        // Read the data
+        int data = reg(RXDATA);
+    
+        return data;
+    }
+    
+
+    bool try_get(int * data) {
+        // Check if there is data to read
+        if (!ready_to_get()){return false;}
+
+        // Read the data
+        *data = reg(RXDATA);
+
+        return true;
+    }
+
+
+    bool try_put(int data) {
+        // Check if there is space to write
+        if (!ready_to_put()){return false;}
+
+        // Write the data
+        reg(TXDATA) = data;
+        return true;
+    }
+
+    int read(char * data, unsigned int max_size) {
+        unsigned int count = 0;
+
+        // Read data until we reach the maximum size or there is no more data
+        while (count < max_size && try_get((int *) (data + count))) {
+            count++;
+        }
+
+        return count;
+    }
+
+    int write(const char * data, unsigned int size) {
+        unsigned int count = 0;
+
+        // Write data until we reach the maximum size or there is no more space
+        while (count < size && try_put((int) *(data + count))) {
+            count++;
+        }
+
+        return count;
+    }
+
+    void flush() {
+        // Flush the SPI
+        //The purpose of this loop is to wait until the SPI interface is 
+        //not busy before proceeding with the next operation.
+        while ((reg(IP) & 0x3) != 0) {}
+    }
+
+    bool ready_to_get()
+    {
+        // we decided to use the IP for dont read the rxdata
+        // another approach is the !(reg(RXDATA) & (1 << 31)) 
+        // but using it would make we consume the register
+        return ((reg(IP) & 0x2) != 0);
+    }
+
+    bool ready_to_put() {
+        // Check if TXFIFO is not full
+        // another approach is the !(reg(TXDATA) & (1 << 31)) 
+       return (((reg(IP) & 0x1) != 0));
+    }
+    
+
+private:
+    static volatile CPU::Reg32 & reg(unsigned int o) { return reinterpret_cast<volatile CPU::Reg32 *>(Memory_Map::QSPI1_BASE)[o / sizeof(CPU::Reg32)]; 
+}
+};
+
+__END_SYS
+
+#endif
diff --git a/include/machine/riscv/sifive_u/sifive_u_memory_map.h b/include/machine/riscv/sifive_u/sifive_u_memory_map.h
index e02d7bf..0282691 100644
--- a/include/machine/riscv/sifive_u/sifive_u_memory_map.h
+++ b/include/machine/riscv/sifive_u/sifive_u_memory_map.h
@@ -38,6 +38,7 @@ public:
         OTP_BASE        = emulated ? NOT_USED : 0x10070000,   // SiFive-U OTP
         ETH_BASE        = emulated ? NOT_USED : 0x10090000,   // SiFive-U Ethernet
         FLASH_BASE      = 0x20000000,   // Virt / SiFive-U Flash
+        QSPI1_BASE = 0x10050000, // We choose the spi on the device tree with the mmc device
 
         // Physical Memory at Boot
         BOOT            = Traits<Machine>::BOOT,
diff --git a/makedefs b/makedefs
index 286b177..7596fcd 100644
--- a/makedefs
+++ b/makedefs
@@ -100,8 +100,11 @@ UUID		= $(shell cat /proc/sys/kernel/random/uuid | sed 's/-//g')
 ia32_COMP_PREFIX	:= /usr/bin/x86_64-linux-gnu-
 armv7_COMP_PREFIX	:= /usr/bin/arm-none-eabi-
 armv8_COMP_PREFIX	:= /usr/bin/aarch64-linux-gnu-
-rv32_COMP_PREFIX	:= /usr/local/rv32/bin/riscv32-unknown-linux-gnu-
-rv64_COMP_PREFIX	:= /usr/bin/riscv64-linux-gnu-
+#rv32_COMP_PREFIX	:= /usr/local/rv32/bin/riscv32-unknown-linux-gnu-
+#rv64_COMP_PREFIX	:= /usr/bin/riscv64-linux-gnu-
+rv32_COMP_PREFIX	:= /home/larissagr/riscv_fin/bin/riscv32-unknown-linux-gnu-
+rv64_COMP_PREFIX	:= /home/larissagr/Documentos/UFSC/UFSC2023/SO2/riscv64/bin/riscv64-unknown-linux-gnu-
+
 COMP_PREFIX		= $($(ARCH)_COMP_PREFIX)
 
 # Architecture specifics
@@ -210,7 +213,7 @@ ifeq ($(ARCH),rv64)
 riscv_CC_FLAGS		:= -march=rv64gc -mabi=lp64d -Wl, -mno-relax -mcmodel=medany
 riscv_AS_FLAGS		:= -march=rv64gc -mabi=lp64d
 riscv_LD_FLAGS		:= -m elf64lriscv_lp64f --no-relax
-riscv_EMULATOR		= qemu-system-riscv64 $(QEMU_DEBUG) -machine sifive_u -smp 2 -m $(MEM_SIZE)k -serial mon:stdio -bios none -nographic -no-reboot $(BOOT_ROM) -kernel 
+riscv_EMULATOR		= qemu-system-riscv64 $(QEMU_DEBUG)  -machine sifive_u -smp 2 -m $(MEM_SIZE)k -serial mon:stdio -bios none -nographic -no-reboot $(BOOT_ROM) -kernel 
 else
 riscv_CC_FLAGS      := -march=rv32gc -mabi=ilp32d -Wl, -mno-relax
 riscv_AS_FLAGS      := -march=rv32gc -mabi=ilp32d
diff --git a/qemu.dts b/qemu.dts
new file mode 100644
index 0000000..f543608
--- /dev/null
+++ b/qemu.dts
@@ -0,0 +1,242 @@
+/dts-v1/;
+
+/ {
+	#address-cells = <0x02>;
+	#size-cells = <0x02>;
+	compatible = "sifive,hifive-unleashed-a00";
+	model = "SiFive HiFive Unleashed A00";
+
+	chosen {
+		stdout-path = "/soc/serial@10010000";
+	};
+
+	aliases {
+		serial0 = "/soc/serial@10010000";
+		serial1 = "/soc/serial@10011000";
+		ethernet0 = "/soc/ethernet@10090000";
+	};
+
+	gpio-restart {
+		compatible = "gpio-restart";
+		gpios = <0x07 0x0a 0x01>;
+	};
+
+	cpus {
+		#address-cells = <0x01>;
+		#size-cells = <0x00>;
+		timebase-frequency = <0xf4240>;
+
+		cpu@0 {
+			device_type = "cpu";
+			reg = <0x00>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv64imac_zicsr_zifencei";
+
+			interrupt-controller {
+				#interrupt-cells = <0x01>;
+				interrupt-controller;
+				compatible = "riscv,cpu-intc";
+				phandle = <0x04>;
+			};
+		};
+
+		cpu@1 {
+			device_type = "cpu";
+			reg = <0x01>;
+			status = "okay";
+			compatible = "riscv";
+			riscv,isa = "rv64imafdc_zicsr_zifencei";
+			mmu-type = "riscv,sv48";
+
+			interrupt-controller {
+				#interrupt-cells = <0x01>;
+				interrupt-controller;
+				compatible = "riscv,cpu-intc";
+				phandle = <0x03>;
+			};
+		};
+	};
+
+	memory@80000000 {
+		device_type = "memory";
+		reg = <0x00 0x80000000 0x00 0x8000000>;
+	};
+
+	rtcclk {
+		#clock-cells = <0x00>;
+		compatible = "fixed-clock";
+		clock-frequency = <0xf4240>;
+		clock-output-names = "rtcclk";
+		phandle = <0x02>;
+	};
+
+	hfclk {
+		#clock-cells = <0x00>;
+		compatible = "fixed-clock";
+		clock-frequency = <0x1fca055>;
+		clock-output-names = "hfclk";
+		phandle = <0x01>;
+	};
+
+	soc {
+		#address-cells = <0x02>;
+		#size-cells = <0x02>;
+		compatible = "simple-bus";
+		ranges;
+
+		serial@10010000 {
+			interrupts = <0x04>;
+			interrupt-parent = <0x06>;
+			clocks = <0x05 0x03>;
+			reg = <0x00 0x10010000 0x00 0x1000>;
+			compatible = "sifive,uart0";
+		};
+
+		serial@10011000 {
+			interrupts = <0x05>;
+			interrupt-parent = <0x06>;
+			clocks = <0x05 0x03>;
+			reg = <0x00 0x10011000 0x00 0x1000>;
+			compatible = "sifive,uart0";
+		};
+
+		pwm@10021000 {
+			#pwm-cells = <0x00>;
+			clocks = <0x05 0x03>;
+			interrupts = <0x2e 0x2f 0x30 0x31>;
+			interrupt-parent = <0x06>;
+			reg = <0x00 0x10021000 0x00 0x1000>;
+			compatible = "sifive,pwm0";
+		};
+
+		pwm@10020000 {
+			#pwm-cells = <0x00>;
+			clocks = <0x05 0x03>;
+			interrupts = <0x2a 0x2b 0x2c 0x2d>;
+			interrupt-parent = <0x06>;
+			reg = <0x00 0x10020000 0x00 0x1000>;
+			compatible = "sifive,pwm0";
+		};
+
+		ethernet@10090000 {
+			#size-cells = <0x00>;
+			#address-cells = <0x01>;
+			local-mac-address = [52 54 00 12 34 56];
+			clock-names = "pclk\0hclk";
+			clocks = <0x05 0x02 0x05 0x02>;
+			interrupts = <0x35>;
+			interrupt-parent = <0x06>;
+			phy-handle = <0x08>;
+			phy-mode = "gmii";
+			reg-names = "control";
+			reg = <0x00 0x10090000 0x00 0x2000 0x00 0x100a0000 0x00 0x1000>;
+			compatible = "sifive,fu540-c000-gem";
+
+			ethernet-phy@0 {
+				reg = <0x00>;
+				phandle = <0x08>;
+			};
+		};
+
+		spi@10040000 {
+			compatible = "sifive,spi0";
+			reg = <0x00 0x10040000 0x00 0x1000>;
+			interrupt-parent = <0x06>;
+			interrupts = <0x33>;
+			clocks = <0x05 0x03>;
+			#address-cells = <0x01>;
+			#size-cells = <0x00>;
+
+			flash@0 {
+				compatible = "jedec,spi-nor";
+				reg = <0x00>;
+				spi-max-frequency = <0x2faf080>;
+				m25p,fast-read;
+				spi-tx-bus-width = <0x04>;
+				spi-rx-bus-width = <0x04>;
+			};
+		};
+
+		spi@10050000 {
+			compatible = "sifive,spi0";
+			reg = <0x00 0x10050000 0x00 0x1000>;
+			interrupt-parent = <0x06>;
+			interrupts = <0x06>;
+			clocks = <0x05 0x03>;
+			#address-cells = <0x01>;
+			#size-cells = <0x00>;
+
+			mmc@0 {
+				compatible = "mmc-spi-slot";
+				reg = <0x00>;
+				spi-max-frequency = <0x1312d00>;
+				voltage-ranges = <0xce4 0xce4>;
+				disable-wp;
+			};
+		};
+
+		cache-controller@2010000 {
+			compatible = "sifive,fu540-c000-ccache";
+			cache-block-size = <0x40>;
+			cache-level = <0x02>;
+			cache-sets = <0x400>;
+			cache-size = <0x200000>;
+			cache-unified;
+			interrupt-parent = <0x06>;
+			interrupts = <0x01 0x02 0x03>;
+			reg = <0x00 0x2010000 0x00 0x1000>;
+		};
+
+		dma@3000000 {
+			compatible = "sifive,fu540-c000-pdma";
+			reg = <0x00 0x3000000 0x00 0x100000>;
+			interrupt-parent = <0x06>;
+			interrupts = <0x17 0x18 0x19 0x1a 0x1b 0x1c 0x1d 0x1e>;
+			#dma-cells = <0x01>;
+		};
+
+		gpio@10060000 {
+			compatible = "sifive,gpio0";
+			interrupt-parent = <0x06>;
+			interrupts = <0x07 0x08 0x09 0x0a 0x0b 0x0c 0x0d 0x0e 0x0f 0x10 0x11 0x12 0x13 0x14 0x15 0x16>;
+			reg = <0x00 0x10060000 0x00 0x1000>;
+			gpio-controller;
+			#gpio-cells = <0x02>;
+			interrupt-controller;
+			#interrupt-cells = <0x02>;
+			clocks = <0x05 0x03>;
+			phandle = <0x07>;
+		};
+
+		interrupt-controller@c000000 {
+			phandle = <0x06>;
+			riscv,ndev = <0x35>;
+			reg = <0x00 0xc000000 0x00 0x4000000>;
+			interrupts-extended = <0x04 0x0b 0x03 0x0b 0x03 0x09>;
+			interrupt-controller;
+			compatible = "sifive,plic-1.0.0\0riscv,plic0";
+			#interrupt-cells = <0x01>;
+		};
+
+		clock-controller@10000000 {
+			compatible = "sifive,fu540-c000-prci";
+			reg = <0x00 0x10000000 0x00 0x1000>;
+			clocks = <0x01 0x02>;
+			#clock-cells = <0x01>;
+			phandle = <0x05>;
+		};
+
+		otp@10070000 {
+			compatible = "sifive,fu540-c000-otp";
+			reg = <0x00 0x10070000 0x00 0x1000>;
+			fuse-count = <0x1000>;
+		};
+
+		clint@2000000 {
+			interrupts-extended = <0x04 0x03 0x04 0x07 0x03 0x03 0x03 0x07>;
+			reg = <0x00 0x2000000 0x00 0x10000>;
+			compatible = "sifive,clint0\0riscv,clint0";
+		};
+	};
+};
